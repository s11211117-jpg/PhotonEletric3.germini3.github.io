<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>光電效應實驗模擬器（物理專業版）</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at 30% 30%, #0f172a, #000000);
      color: #e2e8f0;
      overflow-x: hidden;
      margin: 0;
    }

    /* --- 面板樣式 --- */
    .panel {
      background: rgba(30, 41, 59, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      border-radius: 12px;
    }

    /* --- 滑桿樣式 --- */
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      background: rgba(255,255,255,0.1);
      height: 4px;
      border-radius: 2px;
      cursor: pointer;
      outline: none;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #38bdf8;
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
      border: 2px solid #fff;
      margin-top: -7px;
      transition: transform 0.1s;
    }
    input[type=range]:hover::-webkit-slider-thumb {
      transform: scale(1.2);
    }

    /* --- 顯示字體 --- */
    .font-lcd {
      font-family: 'Courier New', monospace;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    /* --- 儀器與 Canvas 容器 --- */
    .chamber-view {
      position: relative;
      background: linear-gradient(to bottom, #1e293b, #0f172a);
      border-radius: 12px;
      border: 1px solid #334155;
      box-shadow: inset 0 0 50px #000;
      overflow: hidden;
    }

    /* 光學發射器 */
    .emitter-box {
      position: absolute;
      left: 40px; top: 50%; transform: translateY(-50%);
      width: 70px; height: 100px;
      background: #334155;
      border: 1px solid #475569;
      border-radius: 4px;
      z-index: 10;
      display: flex; flex-direction: column; align-items: center;
    }
    .emitter-lens {
      margin-top: auto; margin-bottom: 15px;
      width: 30px; height: 30px;
      border-radius: 50%;
      background: #000;
      border: 2px solid #64748b;
      box-shadow: inset 0 0 5px #000;
    }
    
    /* 電流計 */
    .ammeter {
      position: absolute; top: 15px; right: 15px;
      background: #020617;
      border: 1px solid #1e293b;
      padding: 8px 16px;
      border-radius: 6px;
      text-align: right;
      z-index: 10;
    }
  </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex flex-col">

  <header class="mb-6 flex justify-between items-end max-w-7xl mx-auto w-full border-b border-gray-700 pb-4">
    <div>
      <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
        光電效應實驗 <span class="text-sm text-slate-400 font-normal ml-2 border border-slate-600 px-2 rounded">Pro / Phys</span>
      </h1>
      <p class="text-slate-400 text-xs mt-1">Photoelectric Effect: Quantitative Simulation</p>
    </div>
    <div class="text-right hidden md:block">
      <div class="text-xs text-gray-500">普朗克常數 h ≈ 4.14 × 10⁻¹⁵ eV·s</div>
      <div class="text-xs text-gray-500">光速 c ≈ 3.00 × 10⁸ m/s</div>
    </div>
  </header>

  <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 max-w-7xl mx-auto w-full flex-1">
    
    <aside class="lg:col-span-4 space-y-5">
      <div class="panel p-6 space-y-6">
        <h2 class="text-lg font-bold text-cyan-400 border-b border-white/10 pb-2 mb-4">
          實驗參數設定
        </h2>

        <div class="group">
          <div class="flex justify-between text-sm mb-1">
            <label class="text-gray-300 font-bold">入射光頻率 (Frequency)</label>
            <div class="text-right">
              <span id="val-freq" class="font-lcd text-cyan-300 text-lg">6.00</span>
              <span class="text-xs text-gray-400">×10¹⁴ Hz</span>
            </div>
          </div>
          <input id="inp-freq" type="range" min="3.0" max="15.0" step="0.1" value="6.0" />
          <div class="flex justify-between text-xs mt-1 text-gray-500">
            <span>IR</span>
            <span id="disp-lambda" class="text-cyan-200">λ ≈ 500 nm</span>
            <span>UV</span>
          </div>
          <div class="h-1 w-full mt-1 rounded bg-gradient-to-r from-red-600 via-green-500 to-purple-600 opacity-60"></div>
        </div>

        <div>
          <div class="flex justify-between text-sm mb-1">
            <label class="text-gray-300">輻照度 (Irradiance)</label>
            <div class="text-right">
              <span id="val-int" class="font-lcd text-yellow-300 text-lg">5.0</span>
              <span class="text-xs text-gray-400">W/m² (arb.)</span>
            </div>
          </div>
          <input id="inp-int" type="range" min="0" max="10" step="0.1" value="5.0" />
        </div>

        <div>
          <div class="flex justify-between text-sm mb-1">
            <label class="text-gray-300">金屬功函數 (Work Function)</label>
            <div class="text-right">
              <span id="val-work" class="font-lcd text-orange-300 text-lg">2.30</span>
              <span class="text-xs text-gray-400">eV</span>
            </div>
          </div>
          <input id="inp-work" type="range" min="1.0" max="6.0" step="0.05" value="2.30" />
          <div class="text-[10px] text-gray-500 mt-1 flex justify-between">
            <span>Cs (2.1)</span> <span>Na (2.36)</span> <span>Zn (4.3)</span> <span>Pt (5.6)</span>
          </div>
        </div>

        <div class="bg-black/20 p-4 rounded border border-white/10">
          <div class="flex justify-between text-sm mb-2">
            <label class="text-gray-200 font-bold">反向電壓 (Retarding Voltage)</label>
            <div class="text-right">
              <span id="val-volt" class="font-lcd text-red-400 text-xl">0.00</span>
              <span class="text-xs text-gray-400">V</span>
            </div>
          </div>
          <input id="inp-volt" type="range" min="0" max="8.0" step="0.01" value="0.00" />
          
          <div class="flex gap-3 mt-4">
            <button id="btn-measure" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white text-xs py-2 rounded transition shadow-lg font-bold">
              自動測量截止電壓
            </button>
            <button id="btn-reset" class="px-4 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded transition">
              重置
            </button>
          </div>
        </div>
      </div>

      <div class="panel p-4 text-center">
        <div class="text-[10px] text-gray-500 uppercase tracking-widest mb-1">Photoelectric Equation</div>
        <div class="font-mono text-sm text-white bg-black/40 py-2 px-4 rounded inline-block border border-white/5">
          <span class="text-cyan-300" id="eq-E">0.00</span> = 
          <span class="text-orange-300" id="eq-W">0.00</span> + 
          <span class="text-green-300" id="eq-K">0.00</span>
        </div>
        <div class="text-xs text-gray-500 mt-1">
           hf (eV) = Φ (eV) + Kₘₐₓ (eV)
        </div>
      </div>
    </aside>

    <main class="lg:col-span-8 space-y-6">
      
      <div class="chamber-view h-[350px]">
        <div class="absolute top-2 left-3 text-[10px] text-gray-500 uppercase tracking-widest z-10">Vacuum Chamber</div>
        
        <div class="emitter-box">
          <div class="w-full h-1 bg-black/50 mt-2 mb-1"></div>
          <div class="w-full h-1 bg-black/50 mb-auto"></div>
          <div class="text-[8px] text-gray-500 mb-1">SOURCE</div>
          <div class="emitter-lens" id="lens-core"></div>
        </div>

        <div class="ammeter">
          <div class="text-[9px] text-gray-500 uppercase font-bold">Photocurrent</div>
          <div class="font-lcd text-2xl text-green-400 mt-1" id="disp-curr">0.00</div>
          <div class="text-[10px] text-gray-600">nA</div>
        </div>

        <canvas id="canvas-chamber" class="w-full h-full block"></canvas>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="panel p-4 h-60 flex flex-col">
          <div class="flex justify-between mb-2">
             <span class="text-xs font-bold text-gray-300">光電流 vs 時間 (I-t)</span>
             <span class="text-[10px] text-gray-500" id="disp-ke">Kmax: 0.00 eV</span>
          </div>
          <div class="flex-1 relative w-full overflow-hidden">
            <canvas id="chart-curr"></canvas>
          </div>
        </div>

        <div class="panel p-4 h-60 flex flex-col">
          <div class="flex justify-between items-center mb-2">
             <span class="text-xs font-bold text-gray-300">截止電壓 vs 頻率 (V-f)</span>
             <button id="btn-clear" class="text-[10px] bg-red-900/30 text-red-300 px-2 py-1 rounded hover:bg-red-900/50">清除數據</button>
          </div>
          <div class="flex-1 relative w-full overflow-hidden">
            <canvas id="chart-stop"></canvas>
          </div>
        </div>
      </div>

    </main>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // --- 1. 全域變數與常數 ---
  
  // 真實物理常數 (調整單位以適配模擬)
  // h = 4.1357e-15 eV·s
  // 我們輸入頻率單位是 10^14 Hz
  // 計算 E (eV) = 4.1357e-15 * (f * 1e14) = 0.41357 * f
  const H_EV = 0.41357; 
  const C_SPEED = 300; // 3.00 * 10^8 m/s -> 用於 nm 換算: lambda(nm) = 3e8 / (f*1e14) * 1e9 = 3000 / f

  // 元素綁定
  const els = {
    // Inputs
    freq: document.getElementById('inp-freq'),
    int: document.getElementById('inp-int'),
    work: document.getElementById('inp-work'),
    volt: document.getElementById('inp-volt'),
    
    // Values
    vFreq: document.getElementById('val-freq'),
    vInt: document.getElementById('val-int'),
    vWork: document.getElementById('val-work'),
    vVolt: document.getElementById('val-volt'),
    dispLambda: document.getElementById('disp-lambda'),
    
    // Display & Charts
    dispCurr: document.getElementById('disp-curr'),
    dispKe: document.getElementById('disp-ke'),
    eqE: document.getElementById('eq-E'),
    eqW: document.getElementById('eq-W'),
    eqK: document.getElementById('eq-K'),
    lens: document.getElementById('lens-core'),
    
    // Buttons
    bMeasure: document.getElementById('btn-measure'),
    bReset: document.getElementById('btn-reset'),
    bClear: document.getElementById('btn-clear'),
    
    // Canvas
    cChamber: document.getElementById('canvas-chamber'),
    cCurr: document.getElementById('chart-curr'),
    cStop: document.getElementById('chart-stop')
  };

  // 系統狀態
  let state = {
    w: 0, h: 0,
    photons: [],
    electrons: [],
    sparks: [],
    historyI: [], // 電流歷史
    stopPoints: [], // V-f 點
    isMeasuring: false,
    timer: null
  };

  // 物理狀態
  let phys = {
    f: 0, i: 0, w: 0, v: 0,
    E_photon: 0, K_max: 0, V_stop: 0,
    current: 0, fraction: 0
  };

  // --- 2. 初始化 ---
  function init() {
    resize();
    window.addEventListener('resize', resize);

    // 綁定事件
    [els.freq, els.int, els.work, els.volt].forEach(el => {
      el.addEventListener('input', handleInput);
    });

    els.bReset.addEventListener('click', reset);
    els.bClear.addEventListener('click', () => { state.stopPoints = []; drawStopChart(); });
    els.bMeasure.addEventListener('click', startAutoMeasure);

    // 啟動
    calcPhysics();
    requestAnimationFrame(loop);
  }

  function resize() {
    // 設定 Canvas 解析度
    [els.cChamber, els.cCurr, els.cStop].forEach(c => {
      const rect = c.parentElement.getBoundingClientRect();
      c.width = rect.width;
      c.height = rect.height;
    });
    state.w = els.cChamber.width;
    state.h = els.cChamber.height;
    drawStopChart();
  }

  function handleInput() {
    if (state.isMeasuring && this === els.volt) return;
    calcPhysics();
  }

  function reset() {
    if(state.timer) clearInterval(state.timer);
    state.isMeasuring = false;
    els.bMeasure.disabled = false;
    els.bMeasure.textContent = "自動測量截止電壓";
    els.volt.disabled = false;

    els.freq.value = 6.0;
    els.int.value = 5.0;
    els.work.value = 2.30;
    els.volt.value = 0.00;
    
    state.photons = [];
    state.electrons = [];
    state.historyI = [];
    
    calcPhysics();
  }

  // --- 3. 物理計算核心 ---
  function calcPhysics() {
    const f = parseFloat(els.freq.value);   // 10^14 Hz
    const i = parseFloat(els.int.value);    // 單位強度
    const phi = parseFloat(els.work.value); // eV
    const v = parseFloat(els.volt.value);   // V

    // 1. 光子能量 E = hf
    const E = H_EV * f; // eV

    // 2. 最大動能 Kmax = E - Phi
    const Kmax = Math.max(0, E - phi); // eV

    // 3. 截止電壓 Vstop (數值等於 Kmax，因為 q=1e)
    const Vstop = Kmax; 

    // 4. 電流計算 (模擬費米分佈的簡單版)
    let fraction = 0;
    if (Kmax > 0) {
      if (v >= Vstop) {
        fraction = 0; // 電壓足以阻擋所有電子
      } else if (v < 0) {
        fraction = 1; // 加速電壓
      } else {
        // 當 V < Vstop，電流隨電壓線性(或曲線)下降
        // 這裡使用線性簡化模擬
        fraction = 1 - (v / Vstop);
      }
    }

    // 電流大小 (nA)
    const current = i * fraction * 4.0; // 係數調整用於顯示

    // 波長換算
    const lambda = Math.round(3000 / f); // nm

    // 更新全局
    phys = { f, i, phi, v, E_photon: E, K_max: Kmax, V_stop: Vstop, current, fraction, lambda };

    updateUI();
  }

  function updateUI() {
    // 數值文字
    els.vFreq.innerText = phys.f.toFixed(2);
    els.vInt.innerText = phys.i.toFixed(1);
    els.vWork.innerText = phys.phi.toFixed(2);
    els.vVolt.innerText = phys.v.toFixed(2);
    
    els.dispLambda.innerText = `λ ≈ ${phys.lambda} nm`;
    els.dispCurr.innerText = phys.current.toFixed(2);
    els.dispKe.innerText = `Kmax: ${phys.K_max.toFixed(2)} eV`;

    // 算式
    els.eqE.innerText = phys.E_photon.toFixed(2);
    els.eqW.innerText = phys.phi.toFixed(2);
    els.eqK.innerText = phys.K_max.toFixed(2);

    // 發射器顏色
    const color = wavelengthToColor(phys.lambda);
    els.dispLambda.style.color = color;
    
    if (phys.i > 0) {
      els.lens.style.backgroundColor = color;
      els.lens.style.boxShadow = `0 0 ${phys.i * 2}px ${color}`;
    } else {
      els.lens.style.backgroundColor = '#000';
      els.lens.style.boxShadow = 'none';
    }

    // 記錄圖表
    state.historyI.push(phys.current);
    if(state.historyI.length > 200) state.historyI.shift();
    
    drawStopChart(); // 更新即時游標
  }

  // --- 4. 自動測量 ---
  function startAutoMeasure() {
    if (state.isMeasuring) return;
    if (phys.K_max <= 0) {
      alert("光子能量不足 (E < Φ)，無光電子產生。");
      return;
    }

    state.isMeasuring = true;
    els.bMeasure.disabled = true;
    els.bMeasure.innerText = "測量中...";
    els.volt.disabled = true;
    els.volt.value = 0;

    state.timer = setInterval(() => {
      let v = parseFloat(els.volt.value);
      v += 0.05;
      if (v > 8.0) v = 8.0;
      els.volt.value = v;
      calcPhysics();

      // 停止條件：電流歸零 或 超出量程
      if (phys.current <= 0.02 || v >= 8.0) {
        finishMeasure();
      }
    }, 20);
  }

  function finishMeasure() {
    clearInterval(state.timer);
    state.isMeasuring = false;
    els.bMeasure.disabled = false;
    els.bMeasure.innerText = "自動測量截止電壓";
    els.volt.disabled = false;

    // 記錄真實理論值 (為了實驗教學精確性)
    state.stopPoints.push({ f: phys.f, v: phys.V_stop });
    drawStopChart();
  }

  // --- 5. 繪圖 (Canvas) ---
  const ctxChamber = els.cChamber.getContext('2d');
  const ctxCurr = els.cCurr.getContext('2d');
  const ctxStop = els.cStop.getContext('2d');

  function loop() {
    drawChamber();
    drawCurrentChart();
    requestAnimationFrame(loop);
  }

  function drawChamber() {
    const w = state.w, h = state.h;
    ctxChamber.clearRect(0, 0, w, h);

    // 極板位置
    const cathX = 80; 
    const anoX = w - 80;
    const plateY = h/2 - 60;
    const plateH = 120;

    // 繪製極板
    ctxChamber.fillStyle = '#64748b'; // 陰極
    ctxChamber.fillRect(cathX, plateY, 6, plateH);
    ctxChamber.fillStyle = '#94a3b8'; // 陽極
    ctxChamber.fillRect(anoX, plateY, 6, plateH);

    // 光子生成
    if (phys.i > 0 && Math.random() < phys.i * 0.05) {
      state.photons.push({
        x: 70, y: h/2, // 從發射器位置
        tx: cathX, ty: plateY + Math.random()*plateH,
        p: 0,
        color: wavelengthToColor(phys.lambda)
      });
    }

    // 光子更新
    for(let i = state.photons.length - 1; i >= 0; i--) {
      let pt = state.photons[i];
      pt.p += 0.06;
      
      let cx = pt.x + (pt.tx - pt.x) * pt.p;
      let cy = pt.y + (pt.ty - pt.y) * pt.p;

      ctxChamber.beginPath();
      ctxChamber.strokeStyle = pt.color;
      ctxChamber.lineWidth = 2;
      ctxChamber.moveTo(pt.x + (pt.tx - pt.x) * Math.max(0, pt.p-0.15), 
                        pt.y + (pt.ty - pt.y) * Math.max(0, pt.p-0.15));
      ctxChamber.lineTo(cx, cy);
      ctxChamber.stroke();
      
      ctxChamber.fillStyle = '#fff';
      ctxChamber.beginPath(); ctxChamber.arc(cx, cy, 1.5, 0, Math.PI*2); ctxChamber.fill();

      if(pt.p >= 1) {
        // 撞擊
        spawnSparks(cx, cy, pt.color);
        // 產生電子 (機率)
        if(phys.K_max > 0 && Math.random() > 0.4) {
           spawnElectron(cx, cy);
        }
        state.photons.splice(i, 1);
      }
    }

    // 電子更新
    ctxChamber.fillStyle = '#60a5fa';
    ctxChamber.shadowBlur = 4; ctxChamber.shadowColor = '#3b82f6';
    for(let i = state.electrons.length - 1; i >= 0; i--) {
      let e = state.electrons[i];
      let speed = e.vx;
      
      // 反向電壓阻擋邏輯
      if (!e.pass && e.x > (cathX + anoX)*0.4) {
         speed = -1.5; // 回頭
      }
      
      e.x += speed;
      e.y += e.vy;
      e.life++;

      ctxChamber.beginPath();
      ctxChamber.arc(e.x, e.y, 2.5, 0, Math.PI*2);
      ctxChamber.fill();

      if(e.x >= anoX) {
        if(e.pass) spawnSparks(e.x, e.y, '#93c5fd');
        state.electrons.splice(i, 1);
        continue;
      }
      if(e.x < cathX - 10 || e.life > 200) {
        state.electrons.splice(i, 1);
      }
    }
    ctxChamber.shadowBlur = 0;
    drawSparks();
  }

  function spawnElectron(x, y) {
    const pass = Math.random() < phys.fraction;
    state.electrons.push({
       x, y, 
       vx: 2 + Math.random()*2, 
       vy: (Math.random()-0.5), 
       pass, life: 0 
    });
  }

  function spawnSparks(x, y, c) {
    for(let i=0; i<3; i++) state.sparks.push({x, y, vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2, life:1, c});
  }
  function drawSparks() {
    for(let i=state.sparks.length-1;i>=0;i--){
      let s = state.sparks[i];
      s.x+=s.vx; s.y+=s.vy; s.life-=0.1;
      if(s.life<=0) { state.sparks.splice(i,1); continue; }
      ctxChamber.globalAlpha = s.life;
      ctxChamber.fillStyle = s.c;
      ctxChamber.fillRect(s.x, s.y, 2, 2);
    }
    ctxChamber.globalAlpha = 1;
  }

  function drawCurrentChart() {
    const w = state.w, h = els.cCurr.height;
    ctxCurr.clearRect(0, 0, w, h);
    
    ctxCurr.strokeStyle = 'rgba(255,255,255,0.1)';
    ctxCurr.beginPath(); ctxCurr.moveTo(0, h/2); ctxCurr.lineTo(w, h/2); ctxCurr.stroke();

    if(state.historyI.length < 2) return;

    ctxCurr.strokeStyle = '#4ade80';
    ctxCurr.lineWidth = 2;
    ctxCurr.beginPath();
    const maxI = 50; // Y軸最大值
    state.historyI.forEach((val, i) => {
       const x = (i / 200) * w;
       const y = h - (val / maxI) * h;
       if(i===0) ctxCurr.moveTo(x, y); else ctxCurr.lineTo(x, y);
    });
    ctxCurr.stroke();
  }

  function drawStopChart() {
    const w = state.w, h = els.cStop.height;
    ctxStop.clearRect(0, 0, w, h);
    
    // 坐標軸
    ctxStop.strokeStyle = '#94a3b8';
    ctxStop.lineWidth = 1;
    ctxStop.beginPath();
    ctxStop.moveTo(30, h-20); ctxStop.lineTo(w, h-20); // x
    ctxStop.moveTo(30, h-20); ctxStop.lineTo(30, 0);   // y
    ctxStop.stroke();

    ctxStop.fillStyle = '#94a3b8';
    ctxStop.font = '10px Arial';
    ctxStop.fillText('f (x10¹⁴)', w-45, h-5);
    ctxStop.fillText('Vstop', 5, 10);

    const minF = 3, maxF = 15;
    const maxV = 8;
    const mapX = (f) => 30 + ((f - minF)/(maxF - minF)) * (w-30);
    const mapY = (v) => (h-20) - (v/maxV)*(h-20);

    // 1. 理論線 V = (h/e)f - (W/e)
    // W 是當前設定的功函數
    // 斜率 h/e = 0.41357
    const fStart = phys.phi / H_EV; // f0
    if (fStart < maxF) {
      ctxStop.beginPath();
      ctxStop.strokeStyle = 'rgba(56, 189, 248, 0.3)';
      ctxStop.setLineDash([4,4]);
      ctxStop.moveTo(mapX(fStart), mapY(0));
      const vEnd = H_EV * maxF - phys.phi;
      ctxStop.lineTo(mapX(maxF), mapY(vEnd));
      ctxStop.stroke();
      ctxStop.setLineDash([]);
    }

    // 2. 測量點
    ctxStop.fillStyle = '#f87171';
    state.stopPoints.forEach(p => {
      ctxStop.beginPath(); ctxStop.arc(mapX(p.f), mapY(p.v), 4, 0, Math.PI*2); ctxStop.fill();
    });

    // 3. 當前點
    if(phys.K_max > 0) {
      ctxStop.fillStyle = '#facc15';
      ctxStop.beginPath(); ctxStop.arc(mapX(phys.f), mapY(phys.K_max), 5, 0, Math.PI*2); ctxStop.fill();
    }
  }

  // 波長轉顏色
  function wavelengthToColor(wl) {
    if (wl >= 380 && wl < 440) return '#8b5cf6'; // Violet
    if (wl >= 440 && wl < 490) return '#3b82f6'; // Blue
    if (wl >= 490 && wl < 510) return '#06b6d4'; // Cyan
    if (wl >= 510 && wl < 580) return '#22c55e'; // Green
    if (wl >= 580 && wl < 645) return '#eab308'; // Yellow
    if (wl >= 645 && wl <= 780) return '#ef4444'; // Red
    return '#a8a29e'; // Invisible
  }

  // Start
  init();
});
</script>
</body>
</html>
