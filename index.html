<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>光電效應實驗模擬器（公制單位版）</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* --- 全域設定 --- */
    body {
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, #1e1b4b, #0f172a);
      color: #e2e8f0;
      overflow-x: hidden;
      margin: 0;
    }

    /* --- UI 面板質感 --- */
    .panel {
      background: rgba(30, 41, 59, 0.85);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border-radius: 16px;
    }

    /* --- 滑桿美化 --- */
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      background: rgba(255,255,255,0.1);
      height: 6px;
      border-radius: 5px;
      cursor: pointer;
      outline: none;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #38bdf8;
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.6);
      margin-top: -7px;
      transition: transform 0.1s;
    }
    input[type=range]:hover::-webkit-slider-thumb {
      transform: scale(1.2);
      background: #fff;
    }

    /* --- 按鈕樣式 --- */
    .btn-primary {
      background: linear-gradient(135deg, #0ea5e9, #2563eb);
      box-shadow: 0 4px 15px rgba(37, 99, 235, 0.4);
      transition: all 0.2s ease;
      border: none;
    }
    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(37, 99, 235, 0.6);
    }
    .btn-primary:active { transform: scale(0.98); }
    .btn-primary:disabled { 
      opacity: 0.6; 
      cursor: not-allowed; 
      filter: grayscale(100%);
    }

    /* --- 儀表字體 --- */
    .font-digital {
      font-family: 'Courier New', monospace;
      font-weight: 700;
      letter-spacing: -1px;
    }

    /* --- 光學儀器 CSS --- */
    .optical-device {
      position: absolute;
      width: 90px;
      height: 130px;
      background: linear-gradient(to right, #334155, #1e293b);
      border: 1px solid #475569;
      border-radius: 8px;
      box-shadow: 10px 10px 30px rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 20;
      left: 40px;
      top: 50%;
      transform: translateY(-50%);
    }
    .vent-slot {
      width: 60%; height: 4px; background: #0f172a; margin-top: 6px; border-radius: 2px;
    }
    .lens-housing {
      margin-top: auto; margin-bottom: 15px;
      width: 44px; height: 44px;
      border-radius: 50%;
      background: #334155;
      border: 3px solid #64748b;
      display: flex; align-items: center; justify-content: center;
      box-shadow: inset 0 0 8px #000;
    }
    .lens-core {
      width: 24px; height: 24px; 
      border-radius: 50%; 
      background: #000;
      transition: background-color 0.1s, box-shadow 0.1s;
    }
    .device-label {
      position: absolute; bottom: -25px;
      background: rgba(0,0,0,0.6); padding: 2px 6px;
      border-radius: 4px; font-size: 10px; color: #94a3b8;
      border: 1px solid rgba(255,255,255,0.1);
    }

    /* --- 電流計 --- */
    .ammeter-box {
      position: absolute; top: 20px; right: 20px;
      background: #0f172a; border: 2px solid #334155;
      border-radius: 8px; padding: 10px; width: 140px; /* 稍微加寬以容納科學記號 */
      text-align: center; z-index: 20;
      box-shadow: 0 10px 20px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body class="min-h-screen p-4 md:p-6 flex flex-col items-center">

  <header class="text-center mb-6 w-full max-w-6xl">
    <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
      光電效應實驗室 <span class="text-sm text-slate-300 border border-slate-600 rounded px-2 py-0.5 ml-2 align-middle">SI Metric</span>
    </h1>
    <p class="text-slate-400 text-xs md:text-sm mt-1">Photoelectric Effect: SI Units Simulation (Joules, Volts, Amperes)</p>
  </header>

  <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 w-full max-w-7xl">
    
    <aside class="lg:col-span-4 space-y-5">
      
      <div class="panel p-6 space-y-6">
        <h2 class="text-lg font-bold text-cyan-400 flex items-center gap-2 border-b border-white/10 pb-2">
          <span>⚙️</span> 實驗參數
        </h2>

        <div class="group">
          <div class="flex justify-between text-sm mb-2">
            <label class="text-gray-300">入射光頻率</label>
            <span class="font-mono text-cyan-300 font-bold"><span id="val-freq">6.0</span> ×10¹⁴ Hz</span>
          </div>
          <input id="inp-freq" type="range" min="3" max="15" step="0.1" value="6" />
          <div class="h-1 w-full mt-2 rounded bg-gradient-to-r from-red-500 via-green-500 to-purple-500 opacity-70"></div>
        </div>

        <div>
          <div class="flex justify-between text-sm mb-2">
            <label class="text-gray-300">光強度 (Intensity)</label>
            <span id="val-int" class="font-mono text-yellow-300 font-bold">5</span>
          </div>
          <input id="inp-int" type="range" min="0" max="12" step="1" value="5" />
        </div>

        <div>
          <div class="flex justify-between text-sm mb-2">
            <label class="text-gray-300">金屬臨界頻率 f₀</label>
            <span class="font-mono text-orange-300 font-bold"><span id="val-thresh">7.0</span> ×10¹⁴ Hz</span>
          </div>
          <input id="inp-thresh" type="range" min="3" max="12" step="0.1" value="7" />
          <div class="text-xs text-right text-slate-500 mt-1">功函數 Φ ≈ <span id="disp-work">4.64e-19</span> J</div>
        </div>

        <div class="bg-black/30 p-4 rounded-xl border border-white/10">
          <div class="flex justify-between text-sm mb-2">
            <label class="text-gray-200 font-bold">反向電壓 (V)</label>
            <span id="val-volt" class="font-mono text-red-400 text-xl font-bold">0.00</span>
          </div>
          <input id="inp-volt" type="range" min="0" max="5" step="0.01" value="0" />
          
          <div class="flex gap-2 mt-4">
            <button id="btn-measure" class="flex-1 btn-primary text-white text-xs py-2 rounded flex justify-center items-center gap-2 font-bold">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
              自動測量截止電壓
            </button>
            <button id="btn-reset" class="px-4 bg-slate-600 hover:bg-slate-500 text-white text-xs rounded font-bold transition-colors">
              重置
            </button>
          </div>
        </div>
      </div>

      <div class="panel p-5 space-y-4">
        <div class="text-center">
          <div class="text-gray-500 text-xs mb-1 uppercase tracking-wider">Einstein's Equation (Joules)</div>
          <div class="font-mono text-[11px] md:text-xs text-cyan-300 bg-black/40 border border-white/5 rounded py-2 px-3 inline-block whitespace-nowrap">
            <span id="eq-photon">0.00</span> = <span id="eq-work" class="text-orange-300">0.00</span> + <span id="eq-ke" class="text-white">0.00</span>
          </div>
          <div class="text-gray-600 text-[10px] mt-1">(hν = Φ + Kmax)</div>
        </div>

        <div class="grid grid-cols-2 gap-4 border-t border-white/10 pt-4">
           <div class="text-center">
             <div class="text-xs text-slate-400">最大動能 (Kmax)</div>
             <div class="text-sm md:text-base font-mono text-white"><span id="disp-ke">0.00</span> J</div>
           </div>
           <div class="text-center">
             <div class="text-xs text-green-400">光電流 (I)</div>
             <div class="text-sm md:text-base font-mono text-green-300"><span id="disp-curr">0.00</span> A</div>
           </div>
        </div>
      </div>
    </aside>

    <main class="lg:col-span-8 space-y-5">
      
      <div class="panel p-1 relative overflow-hidden h-[400px] rounded-2xl">
        <div class="relative w-full h-full bg-gradient-to-b from-gray-900 to-slate-900 rounded-xl overflow-hidden">
          
          <div class="absolute top-3 left-4 bg-black/60 backdrop-blur text-xs text-slate-300 px-2 py-1 rounded border border-white/10 z-10">
            Vacuum Chamber View
          </div>

          <div class="optical-device">
            <div class="vent-slot"></div><div class="vent-slot"></div><div class="vent-slot"></div>
            <div class="text-[9px] text-slate-500 mt-2 tracking-widest font-bold">EMITTER</div>
            <div class="lens-housing">
              <div id="lens-core" class="lens-core"></div>
            </div>
            <div id="label-freq" class="device-label">-- Hz</div>
          </div>

          <div class="ammeter-box">
            <div class="text-[9px] text-slate-400 uppercase font-bold tracking-widest mb-1">AMMETER</div>
            <div id="ammeter-val" class="font-digital text-lg text-green-500">0.00</div>
            <div class="text-[10px] text-slate-500">Amperes (A)</div>
          </div>

          <canvas id="canvas-tube" class="absolute inset-0 w-full h-full z-0"></canvas>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
        
        <div class="panel p-4 h-56 flex flex-col">
          <div class="flex justify-between items-end mb-2">
            <h3 class="text-sm font-bold text-slate-300">電流監控 (I - t)</h3>
            <span class="text-[10px] text-slate-500">Real-time Data</span>
          </div>
          <div class="flex-1 bg-black/20 rounded border border-white/5 relative overflow-hidden">
              <canvas id="chart-curr" class="absolute inset-0 w-full h-full"></canvas>
          </div>
        </div>

        <div class="panel p-4 h-56 flex flex-col">
          <div class="flex justify-between items-center mb-2">
            <h3 class="text-sm font-bold text-slate-300">截止電壓 vs 頻率</h3>
            <button id="btn-clear" class="text-[10px] bg-red-500/20 text-red-300 px-2 py-1 rounded hover:bg-red-500/40 transition">
              清除數據
            </button>
          </div>
          <div class="flex-1 bg-black/20 rounded border border-white/5 relative overflow-hidden">
              <canvas id="chart-stop" class="absolute inset-0 w-full h-full"></canvas>
          </div>
        </div>

      </div>
    </main>
  </div>

<script>
/**
 * 光電效應模擬器 (SI 公制單位版)
 * 使用真實物理常數計算：Joules, Coulombs, Hertz, Volts
 */

document.addEventListener('DOMContentLoaded', () => {

  // --- 1. 全域變數與 DOM 綁定 ---
  const els = {
    freq: document.getElementById('inp-freq'),
    int: document.getElementById('inp-int'),
    thresh: document.getElementById('inp-thresh'),
    volt: document.getElementById('inp-volt'),
    
    vFreq: document.getElementById('val-freq'),
    vInt: document.getElementById('val-int'),
    vThresh: document.getElementById('val-thresh'),
    vVolt: document.getElementById('val-volt'),
    
    dWork: document.getElementById('disp-work'),
    dKe: document.getElementById('disp-ke'),
    dCurr: document.getElementById('disp-curr'),
    
    eqP: document.getElementById('eq-photon'),
    eqW: document.getElementById('eq-work'),
    eqK: document.getElementById('eq-ke'),
    
    lens: document.getElementById('lens-core'),
    lFreq: document.getElementById('label-freq'),
    ammeter: document.getElementById('ammeter-val'),
    
    bMeasure: document.getElementById('btn-measure'),
    bReset: document.getElementById('btn-reset'),
    bClear: document.getElementById('btn-clear'),
    
    cTube: document.getElementById('canvas-tube'),
    cCurr: document.getElementById('chart-curr'),
    cStop: document.getElementById('chart-stop')
  };

  const ctxs = {
    tube: els.cTube.getContext('2d'),
    curr: els.cCurr.getContext('2d'),
    stop: els.cStop.getContext('2d')
  };

  // --- 真實物理常數 (SI Units) ---
  const H = 6.626e-34; // 普朗克常數 (J·s)
  const Q = 1.602e-19; // 基本電荷 (C)
  const SCALE_FREQ = 1e14; // 滑桿數值的倍率 (x10^14 Hz)
  const SCALE_CURRENT = 1e-9; // 模擬電流的基礎單位 (1單位 = 1nA = 1e-9 A)
  
  // 系統狀態
  let state = {
    w: 0, h: 0,
    photons: [],
    electrons: [],
    sparks: [],
    history: [],
    stopPoints: [],
    measuring: false,
    measureTimer: null
  };
  
  // 當前物理數值緩存
  let phys = {
    f_input: 6, // 滑桿值
    f_hz: 6e14, // 真實頻率
    i: 5,
    t_input: 7,
    t_hz: 7e14,
    v: 0,
    
    E_joule: 0,
    W_joule: 0,
    K_joule: 0,
    V_stop: 0, // Volts
    current: 0, // Amperes
    fraction: 0
  };

  // 輔助：科學記號格式化
  function toSci(num, decimal = 2) {
    if (num === 0) return "0.00";
    // 處理極小數值的顯示優化
    if (Math.abs(num) < 1e-25) return "0.00"; 
    return num.toExponential(decimal).replace("e+", "e").replace("e", "e");
  }

  // --- 2. 初始化 (Init) ---
  function init() {
    handleResize();
    window.addEventListener('resize', handleResize);

    [els.freq, els.int, els.thresh, els.volt].forEach(inp => {
      inp.addEventListener('input', onInput);
    });

    els.bReset.addEventListener('click', resetSim);
    els.bClear.addEventListener('click', () => {
      state.stopPoints = [];
      drawStopChart();
    });
    els.bMeasure.addEventListener('click', startAutoMeasure);

    updatePhysics();
    requestAnimationFrame(animationLoop);
  }

  function handleResize() {
    [els.cTube, els.cCurr, els.cStop].forEach(c => {
      const rect = c.parentElement.getBoundingClientRect();
      c.width = rect.width;
      c.height = rect.height;
    });
    state.w = els.cTube.width;
    state.h = els.cTube.height;
    drawStopChart();
  }

  function onInput() {
    if (state.measuring && this === els.volt) return;
    updatePhysics();
  }

  function resetSim() {
    if(state.measureTimer) clearInterval(state.measureTimer);
    state.measuring = false;
    els.bMeasure.disabled = false;
    els.bMeasure.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> 自動測量截止電壓`;
    els.volt.disabled = false;

    els.freq.value = 6;
    els.int.value = 5;
    els.thresh.value = 7;
    els.volt.value = 0;

    state.photons = [];
    state.electrons = [];
    state.history = [];
    
    updatePhysics();
  }

  // --- 3. 核心物理引擎 (Physics Engine) ---
  function updatePhysics() {
    // 讀取輸入
    const f_in = parseFloat(els.freq.value);
    const i_in = parseInt(els.int.value);
    const t_in = parseFloat(els.thresh.value);
    const v_in = parseFloat(els.volt.value); // 反向電壓 (Volts)

    // 換算為公制
    const f_hz = f_in * SCALE_FREQ;
    const t_hz = t_in * SCALE_FREQ;

    // 1. 能量計算 (Joules)
    const E_joule = H * f_hz;       // E = hf
    const W_joule = H * t_hz;       // W = hf0
    const K_joule = Math.max(0, E_joule - W_joule); // Kmax = E - W

    // 2. 截止電壓 (Volts)
    // Kmax (J) = q (C) * Vstop (V)  => Vstop = Kmax / q
    const V_stop = K_joule / Q; 

    // 3. 電流計算 (模擬)
    let fraction = 0;
    
    if (K_joule > 0) {
      if (v_in >= V_stop) {
        fraction = 0;
      } else if (v_in < 0) {
        fraction = 1; // 加速電壓
      } else {
        // 線性模擬：電壓越接近 V_stop，電流越小
        fraction = 1 - (v_in / V_stop);
      }
    }
    
    // 計算模擬電流 (Amperes)
    // 假設最大光強對應約 12 * 2.5 nA 的等級
    const current_amp = i_in * fraction * 2.5 * SCALE_CURRENT;

    // 4. 更新全域狀態
    phys = { 
      f_input: f_in, f_hz, 
      i: i_in, 
      t_input: t_in, t_hz, 
      v: v_in,
      E_joule, W_joule, K_joule, V_stop, 
      current: current_amp, 
      fraction 
    };

    // 5. 更新 UI
    els.vFreq.innerText = f_in.toFixed(1);
    els.vInt.innerText = i_in;
    els.vThresh.innerText = t_in.toFixed(1);
    els.vVolt.innerText = v_in.toFixed(2);
    
    // 使用科學記號顯示能量
    els.dWork.innerText = toSci(W_joule);
    els.dKe.innerText = toSci(K_joule);
    els.dCurr.innerText = toSci(current_amp);
    
    els.eqP.innerText = toSci(E_joule);
    els.eqW.innerText = toSci(W_joule);
    els.eqK.innerText = toSci(K_joule);

    // 更新儀器
    els.ammeter.innerText = toSci(current_amp);
    
    const color = getHslColor(f_in);
    els.lFreq.innerText = f_in.toFixed(1) + "e14 Hz";
    els.lFreq.style.color = color;
    
    if (i_in > 0) {
      els.lens.style.backgroundColor = color;
      const glow = i_in * 3;
      els.lens.style.boxShadow = `0 0 ${glow}px ${color}`;
    } else {
      els.lens.style.backgroundColor = '#000';
      els.lens.style.boxShadow = 'none';
    }

    // 記錄歷史 (儲存為 nA 以便繪圖顯示幅度，或直接存 Amp 但繪圖時正規化)
    // 這裡為了繪圖方便，我們存 "相對強度" (0-30 scale)
    state.history.push(phys.current / SCALE_CURRENT); 
    if(state.history.length > 200) state.history.shift();

    drawStopChart();
  }

  // --- 4. 自動測量功能 ---
  function startAutoMeasure() {
    if (state.measuring) return;
    
    if (phys.K_joule <= 1e-25) { // 能量極小視為 0
      alert("能量不足 (f < f₀)，無光電子產生，無法測量截止電壓。");
      return;
    }

    state.measuring = true;
    els.bMeasure.disabled = true;
    els.bMeasure.innerText = "測量中...";
    els.volt.disabled = true;
    
    els.volt.value = 0;
    updatePhysics();

    state.measureTimer = setInterval(() => {
      let v = parseFloat(els.volt.value);
      v += 0.02; // 稍微放慢步進以求精確
      if (v > 5) v = 5; // 限制最大掃描電壓
      
      els.volt.value = v;
      updatePhysics();

      // 當電流歸零 (小於極小值)
      if (phys.current <= 0.05 * SCALE_CURRENT || v >= 5) {
        finishMeasure();
      }
    }, 20);
  }

  function finishMeasure() {
    clearInterval(state.measureTimer);
    state.measuring = false;
    els.bMeasure.disabled = false;
    els.bMeasure.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> 自動測量截止電壓`;
    els.volt.disabled = false;

    state.stopPoints.push({ f: phys.f_input, v: phys.V_stop });
    drawStopChart();
  }

  // --- 5. 動畫渲染 ---
  function animationLoop() {
    const ctx = ctxs.tube;
    const w = state.w;
    const h = state.h;

    ctx.clearRect(0, 0, w, h);

    // 極板
    const plateY = h * 0.25;
    const plateH = h * 0.5;
    const cathX = w * 0.25;
    const anoX = w * 0.75;

    ctx.fillStyle = '#64748b';
    ctx.fillRect(cathX, plateY, 8, plateH); 
    ctx.fillStyle = '#94a3b8';
    ctx.fillRect(anoX, plateY, 8, plateH);

    // 發射光子
    if (phys.i > 0 && Math.random() < phys.i * 0.05) {
      state.photons.push({
        x: 85, 
        y: h / 2, 
        tx: cathX, 
        ty: plateY + Math.random() * plateH, 
        progress: 0,
        color: getHslColor(phys.f_input)
      });
    }

    // 光子邏輯
    for (let i = state.photons.length - 1; i >= 0; i--) {
      let p = state.photons[i];
      p.progress += 0.05;

      let cx = p.x + (p.tx - p.x) * p.progress;
      let cy = p.y + (p.ty - p.y) * p.progress;

      ctx.beginPath();
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 2;
      ctx.moveTo(p.x + (p.tx - p.x) * Math.max(0, p.progress - 0.1), 
                 p.y + (p.ty - p.y) * Math.max(0, p.progress - 0.1));
      ctx.lineTo(cx, cy);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.fillStyle = '#fff';
      ctx.arc(cx, cy, 2, 0, Math.PI*2);
      ctx.fill();

      if (p.progress >= 1) {
        createSpark(cx, cy, p.color);
        // 有動能才產生電子
        if (phys.K_joule > 0 && Math.random() > 0.3) {
          spawnElectron(cx, cy);
        }
        state.photons.splice(i, 1);
      }
    }

    // ... (在 animationLoop 內部) ...

    // 3. 電子運動邏輯
    ctx.fillStyle = '#60a5fa'; 
    ctx.shadowBlur = 4; 
    ctx.shadowColor = '#3b82f6';

    for (let i = state.electrons.length - 1; i >= 0; i--) {
      let e = state.electrons[i];
      
      e.x += e.vx; // 移動
      e.y += e.vy;
      
      // [新增] 折返邏輯：如果這顆電子有設定折返點，且飛過了頭 -> 掉頭
      if (e.turnX !== null && e.x >= e.turnX && e.vx > 0) {
        e.vx *= -1;     // 速度反轉 (變負的，往回飛)
        e.turnX = null; // 標記已折返，避免重複判斷
      }

      ctx.beginPath(); 
      ctx.arc(e.x, e.y, 3, 0, Math.PI*2); 
      ctx.fill();

      // 邊界檢查
      if (e.x >= state.anoX) { 
        // 成功抵達陽極 (只有能量夠大的才會到這)
        createSpark(e.x, e.y, '#93c5fd');
        state.electrons.splice(i, 1);
      } else if (e.x < state.cathX && e.vx < 0) { 
        // [新增] 被反向電壓推回陰極，消失
         state.electrons.splice(i, 1);
      } else if (e.y < 0 || e.y > state.h) { 
        // 飛出上下邊界
        state.electrons.splice(i, 1);
      }
    }
    ctx.shadowBlur = 0;

    // ... (後面的 drawSparks 等等保持不變) ...

    drawSparks(ctx);
    drawCurrentChart();

    requestAnimationFrame(animationLoop);
  }

  // --- 生成電子 (決定命運的地方) ---
  function spawnElectron(x, y) {
  // 1. 隨機決定這顆電子的能量 (0% ~ 100% 的最大動能)
    const myEnergyRatio = Math.random(); 
    const myEnergy = phys.K_joule * myEnergyRatio;
  
  // 2. 計算反向電壓形成的能量障壁 (Barrier = q * V)
    const barrierEnergy = phys.v * Q; // Q 是全域變數 1.602e-19

    let turnX = null; // 預設為 null 表示會通過
    let speed = 2 + myEnergyRatio * 4; // 視覺速度：能量越大飛越快

  // 3. 關鍵判斷：如果 "反向電壓存在" 且 "我的能量 < 障壁能量" -> 必須折返
    if (phys.v > 0 && myEnergy < barrierEnergy) {
     // 計算折返點：能量越低，越早折返；能量越高，飛越遠才折返
       const dist = state.anoX - state.cathX;
     
     // 算出它能克服幾成的障壁 (0.0 ~ 1.0)
     // 限制最多飛到 95% 的距離 (避免看起來像撞到對面才回頭，那樣很怪)
       let progress = myEnergy / barrierEnergy;
       if (progress > 0.95) progress = 0.95;
     
       turnX = state.cathX + 10 + (dist * progress);
    }

    state.electrons.push({
      x: x, y: y,
      vx: speed, 
      vy: (Math.random() - 0.5) * 1.5, // 微微的上下飄動
      turnX: turnX // 把命運寫在電子身上
    });
  }

  function createSpark(x, y, color) {
    for(let i=0; i<4; i++) {
      state.sparks.push({
        x, y, 
        vx: (Math.random()-0.5)*3, 
        vy: (Math.random()-0.5)*3, 
        life: 1.0, 
        color
      });
    }
  }

  function drawSparks(ctx) {
    for(let i=state.sparks.length-1; i>=0; i--) {
      let s = state.sparks[i];
      s.x += s.vx; s.y += s.vy; s.life -= 0.1;
      if (s.life <= 0) {
        state.sparks.splice(i, 1);
        continue;
      }
      ctx.globalAlpha = s.life;
      ctx.fillStyle = s.color;
      ctx.fillRect(s.x, s.y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  // --- 6. 圖表繪製 ---
  function drawCurrentChart() {
    const ctx = ctxs.curr;
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);
    
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();

    if (state.history.length < 2) return;

    ctx.beginPath();
    ctx.strokeStyle = '#4ade80';
    ctx.lineWidth = 2;

    const maxVal = 35; // 對應大約的顯示範圍
    for (let i = 0; i < state.history.length; i++) {
      const x = (i / 200) * w;
      // state.history 存的是相對值 (nA 數值)，所以直接用
      const y = h - (state.history[i] / maxVal) * h;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  function drawStopChart() {
    const ctx = ctxs.stop;
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    // 軸線
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(35, h - 20); ctx.lineTo(w, h - 20);
    ctx.moveTo(35, h - 20); ctx.lineTo(35, 0);
    ctx.stroke();

    // 標籤
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '10px Arial';
    ctx.fillText('f (x10¹⁴)', w - 45, h - 5);
    ctx.fillText('V stop', 2, 12);

    // 映射 (X: 頻率係數, Y: 電壓 Volts)
    const fMin = 3, fMax = 15;
    const vMax = 4; // 調整顯示範圍以適應真實數值
    const mapX = (f) => 35 + ((f - fMin) / (fMax - fMin)) * (w - 35);
    const mapY = (v) => (h - 20) - (v / vMax) * (h - 20);

    // 1. 理論線 (Slope = h/e)
    // V = (h/e)*f - (W/e)
    const slope = (H * SCALE_FREQ) / Q; // 約 0.41 V per 10^14 Hz
    
    const fStart = Math.max(fMin, phys.t_input);
    if (fStart < fMax) {
      const vStart = 0;
      // 計算 fMax 處的理論 V_stop
      // V = (h * (fMax - f0) * 10^14) / e
      const vEnd = (H * (fMax - phys.t_input) * SCALE_FREQ) / Q;
      
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)';
      ctx.setLineDash([4, 4]);
      ctx.moveTo(mapX(fStart), mapY(vStart));
      ctx.lineTo(mapX(fMax), mapY(vEnd));
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // 2. 測量點
    ctx.fillStyle = '#f87171';
    state.stopPoints.forEach(p => {
      ctx.beginPath();
      ctx.arc(mapX(p.f), mapY(p.v), 4, 0, Math.PI * 2);
      ctx.fill();
    });

    // 3. 當前點
    if (phys.K_joule > 0) {
      const cx = mapX(phys.f_input);
      const cy = mapY(phys.V_stop);
      
      ctx.fillStyle = '#facc15';
      ctx.beginPath();
      ctx.arc(cx, cy, 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#fff';
      ctx.fillText("Now", cx + 8, cy);
    }
  }

  function getHslColor(f) {
    const ratio = (f - 3) / 12;
    const hue = ratio * 270; 
    return `hsl(${300 - hue}, 100%, 60%)`;
  }

  init();

});
</script>
</body>
</html>
