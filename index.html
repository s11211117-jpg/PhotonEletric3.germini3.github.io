<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>光電效應實驗（經典金屬板版）</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at 30% 30%, #0f172a, #000000);
      color: #e2e8f0;
      margin: 0;
    }

    /* --- 面板樣式 --- */
    .panel {
      background: rgba(30, 41, 59, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      border-radius: 12px;
    }

    /* --- 滑桿優化 --- */
    input[type=range] {
      -webkit-appearance: none;
      width: 100%;
      background: rgba(255,255,255,0.1);
      height: 4px;
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: #38bdf8;
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
      border: 2px solid #fff;
      margin-top: -7px;
      transition: transform 0.1s;
    }
    input[type=range]:hover::-webkit-slider-thumb { transform: scale(1.2); }

    .font-lcd { font-family: 'Courier New', monospace; font-weight: 700; }

    /* --- 實驗裝置容器 --- */
    .chamber-container {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #334155;
      background: linear-gradient(to bottom, #1e293b, #0f172a);
      box-shadow: inset 0 0 50px #000;
    }

    /* 光學發射器 (外部裝飾) */
    .source-box {
      position: absolute;
      left: -10px; top: 40%;
      width: 60px; height: 80px;
      background: #334155;
      border: 1px solid #475569;
      transform: rotate(-15deg); /* 稍微傾斜照射 */
      z-index: 10;
      display: flex; justify-content: center; align-items: flex-end;
      padding-bottom: 10px;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
    }
    .lens {
      width: 30px; height: 30px;
      border-radius: 50%;
      background: #000;
      border: 2px solid #64748b;
      box-shadow: inset 0 0 5px #000;
    }

    /* 電流計 */
    .ammeter {
      position: absolute; top: 15px; right: 15px;
      background: rgba(2, 6, 23, 0.85);
      border: 1px solid #1e293b;
      padding: 8px 16px;
      border-radius: 6px;
      text-align: right;
      z-index: 10;
    }
  </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex flex-col">

  <header class="mb-6 flex justify-between items-end max-w-7xl mx-auto w-full border-b border-gray-700 pb-4">
    <div>
      <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
        光電效應實驗 <span class="text-sm text-slate-400 font-normal ml-2 border border-slate-600 px-2 rounded">金屬板裝置版</span>
      </h1>
      <p class="text-slate-400 text-xs mt-1">Photoelectric Effect: Parallel Plates Experiment</p>
    </div>
    <div class="text-right hidden md:block">
      <div class="text-xs text-gray-500">h ≈ 4.14 × 10⁻¹⁵ eV·s</div>
    </div>
  </header>

  <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 max-w-7xl mx-auto w-full flex-1">
    
    <aside class="lg:col-span-4 space-y-5">
      <div class="panel p-6 space-y-6">
        <h2 class="text-lg font-bold text-cyan-400 border-b border-white/10 pb-2 mb-4">參數設定</h2>

        <div>
          <div class="flex justify-between text-sm mb-1">
            <label class="text-gray-300 font-bold">入射光頻率 (Freq)</label>
            <div class="text-right">
              <span id="val-freq" class="font-lcd text-cyan-300 text-lg">6.00</span>
              <span class="text-xs text-gray-400">×10¹⁴ Hz</span>
            </div>
          </div>
          <input id="inp-freq" type="range" min="3.0" max="15.0" step="0.1" value="6.0" />
          <div class="flex justify-between text-xs mt-1 text-gray-500">
            <span>IR</span>
            <span id="disp-lambda" class="text-cyan-200">λ ≈ 500 nm</span>
            <span>UV</span>
          </div>
          <div class="h-1.5 w-full mt-1 rounded-full" style="background: linear-gradient(to right, #7f1d1d, #ef4444, #eab308, #22c55e, #3b82f6, #8b5cf6, #d8b4fe);"></div>
        </div>

        <div>
          <div class="flex justify-between text-sm mb-1">
            <label class="text-gray-300">光強度 (Intensity)</label>
            <div>
              <span id="val-int" class="font-lcd text-yellow-300 text-lg">5.0</span>
            </div>
          </div>
          <input id="inp-int" type="range" min="0" max="10" step="0.1" value="5.0" />
        </div>

        <div>
          <div class="flex justify-between text-sm mb-1">
            <label class="text-gray-300">金屬功函數 (Work Func)</label>
            <div>
              <span id="val-work" class="font-lcd text-orange-300 text-lg">2.30</span>
              <span class="text-xs text-gray-400">eV</span>
            </div>
          </div>
          <input id="inp-work" type="range" min="1.0" max="6.0" step="0.05" value="2.30" />
          <div class="text-[10px] text-gray-500 mt-1 flex justify-between">
            <span>Cs(2.1)</span> <span>Na(2.36)</span> <span>Zn(4.3)</span> <span>Pt(5.6)</span>
          </div>
        </div>

        <div class="bg-black/20 p-4 rounded border border-white/10">
          <div class="flex justify-between text-sm mb-2">
            <label class="text-gray-200 font-bold">反向電壓 (Stopping V)</label>
            <div>
              <span id="val-volt" class="font-lcd text-red-400 text-xl">0.00</span>
              <span class="text-xs text-gray-400">V</span>
            </div>
          </div>
          <input id="inp-volt" type="range" min="0" max="8.0" step="0.01" value="0.00" />
          
          <div class="flex gap-3 mt-4">
            <button id="btn-measure" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white text-xs py-2 rounded font-bold shadow-lg transition">
              自動測量
            </button>
            <button id="btn-reset" class="px-3 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded transition">
              重置
            </button>
          </div>
        </div>
      </div>

      <div class="panel p-4 text-center">
        <div class="font-mono text-sm text-white bg-black/40 py-2 px-4 rounded inline-block border border-white/5">
          <span class="text-cyan-300" id="eq-E">0.00</span> = 
          <span class="text-orange-300" id="eq-W">0.00</span> + 
          <span class="text-green-300" id="eq-K">0.00</span>
        </div>
        <div class="text-xs text-gray-500 mt-1">E (eV) = Φ + Kmax</div>
      </div>
    </aside>

    <main class="lg:col-span-8 space-y-6">
      
      <div class="chamber-container h-[400px]">
        <div class="source-box">
           <div class="lens" id="lens-core"></div>
        </div>

        <div class="ammeter">
          <div class="text-[9px] text-gray-500 uppercase font-bold">Current</div>
          <div class="font-lcd text-2xl text-green-400 mt-1" id="disp-curr">0.00</div>
          <div class="text-[10px] text-gray-600">nA</div>
        </div>

        <canvas id="canvas-chamber" class="absolute inset-0 w-full h-full"></canvas>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="panel p-4 h-56 flex flex-col">
          <div class="flex justify-between mb-1">
             <span class="text-xs font-bold text-gray-300">I - t 圖</span>
             <span class="text-[10px] text-gray-500" id="disp-ke">Kmax: 0.00 eV</span>
          </div>
          <div class="flex-1 w-full relative"><canvas id="chart-curr"></canvas></div>
        </div>

        <div class="panel p-4 h-56 flex flex-col">
          <div class="flex justify-between items-center mb-1">
             <span class="text-xs font-bold text-gray-300">截止電壓 (V-f)</span>
             <button id="btn-clear" class="text-[10px] bg-red-900/40 text-red-200 px-2 py-0.5 rounded">清除</button>
          </div>
          <div class="flex-1 w-full relative"><canvas id="chart-stop"></canvas></div>
        </div>
      </div>

    </main>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // --- 物理常數 ---
  const H_EV = 0.41357; // 輸入頻率為 10^14 Hz 時的 h 值

  const els = {
    freq: document.getElementById('inp-freq'),
    int: document.getElementById('inp-int'),
    work: document.getElementById('inp-work'),
    volt: document.getElementById('inp-volt'),
    vFreq: document.getElementById('val-freq'),
    vInt: document.getElementById('val-int'),
    vWork: document.getElementById('val-work'),
    vVolt: document.getElementById('val-volt'),
    dispLambda: document.getElementById('disp-lambda'),
    dispCurr: document.getElementById('disp-curr'),
    dispKe: document.getElementById('disp-ke'),
    eqE: document.getElementById('eq-E'),
    eqW: document.getElementById('eq-W'),
    eqK: document.getElementById('eq-K'),
    lens: document.getElementById('lens-core'),
    bMeasure: document.getElementById('btn-measure'),
    bReset: document.getElementById('btn-reset'),
    bClear: document.getElementById('btn-clear'),
    cChamber: document.getElementById('canvas-chamber'),
    cCurr: document.getElementById('chart-curr'),
    cStop: document.getElementById('chart-stop')
  };

  let state = {
    w: 0, h: 0,
    photons: [], electrons: [], sparks: [],
    historyI: [], stopPoints: [],
    isMeasuring: false, timer: null
  };

  let phys = {
    f: 0, i: 0, phi: 0, v: 0,
    E: 0, Kmax: 0, Vstop: 0,
    current: 0, fraction: 0, lambda: 0
  };

  // --- 初始化 ---
  function init() {
    resize();
    window.addEventListener('resize', resize);
    [els.freq, els.int, els.work, els.volt].forEach(el => el.addEventListener('input', handleInput));
    els.bReset.addEventListener('click', reset);
    els.bClear.addEventListener('click', () => { state.stopPoints = []; drawStopChart(); });
    els.bMeasure.addEventListener('click', startAutoMeasure);
    calcPhysics();
    requestAnimationFrame(loop);
  }

  function resize() {
    [els.cChamber, els.cCurr, els.cStop].forEach(c => {
      const rect = c.parentElement.getBoundingClientRect();
      c.width = rect.width; c.height = rect.height;
    });
    state.w = els.cChamber.width; state.h = els.cChamber.height;
    drawStopChart();
  }

  function handleInput() {
    if (state.isMeasuring && this === els.volt) return;
    calcPhysics();
  }

  function reset() {
    if(state.timer) clearInterval(state.timer);
    state.isMeasuring = false;
    els.bMeasure.disabled = false; els.bMeasure.textContent = "自動測量";
    els.volt.disabled = false;
    els.freq.value = 6.0; els.int.value = 5.0; els.work.value = 2.30; els.volt.value = 0.00;
    state.photons = []; state.electrons = []; state.historyI = [];
    calcPhysics();
  }

  // --- 物理計算 ---
  function calcPhysics() {
    const f = parseFloat(els.freq.value);
    const i = parseFloat(els.int.value);
    const phi = parseFloat(els.work.value);
    const v = parseFloat(els.volt.value);

    const E = H_EV * f;
    const Kmax = Math.max(0, E - phi);
    const Vstop = Kmax;

    let fraction = 0;
    if (Kmax > 0) {
      if (v >= Vstop) fraction = 0;
      else if (v < 0) fraction = 1;
      else fraction = 1 - (v / Vstop);
    }
    const current = i * fraction * 4.0;
    const lambda = Math.round(3000 / f);

    phys = { f, i, phi, v, E, Kmax, Vstop, current, fraction, lambda };
    updateUI();
  }

  function updateUI() {
    els.vFreq.innerText = phys.f.toFixed(2);
    els.vInt.innerText = phys.i.toFixed(1);
    els.vWork.innerText = phys.phi.toFixed(2);
    els.vVolt.innerText = phys.v.toFixed(2);
    
    // 顏色邏輯修正
    const color = wavelengthToColor(phys.lambda);
    els.dispLambda.innerText = `λ ≈ ${phys.lambda} nm`;
    els.dispLambda.style.color = color;
    
    els.dispCurr.innerText = phys.current.toFixed(2);
    els.dispKe.innerText = `Kmax: ${phys.Kmax.toFixed(2)} eV`;
    
    els.eqE.innerText = phys.E.toFixed(2);
    els.eqW.innerText = phys.phi.toFixed(2);
    els.eqK.innerText = phys.Kmax.toFixed(2);

    if (phys.i > 0) {
      els.lens.style.backgroundColor = color;
      els.lens.style.boxShadow = `0 0 ${phys.i * 4}px ${color}`;
    } else {
      els.lens.style.backgroundColor = '#000';
      els.lens.style.boxShadow = 'none';
    }

    state.historyI.push(phys.current);
    if(state.historyI.length > 200) state.historyI.shift();
    drawStopChart();
  }

  // --- 自動測量 ---
  function startAutoMeasure() {
    if (state.isMeasuring) return;
    if (phys.Kmax <= 0) { alert("能量不足 (E < Φ)"); return; }
    state.isMeasuring = true;
    els.bMeasure.disabled = true; els.bMeasure.innerText = "測量中...";
    els.volt.disabled = true; els.volt.value = 0;
    state.timer = setInterval(() => {
      let v = parseFloat(els.volt.value); v += 0.05; if (v > 8.0) v = 8.0;
      els.volt.value = v; calcPhysics();
      if (phys.current <= 0.02 || v >= 8.0) finishMeasure();
    }, 20);
  }
  function finishMeasure() {
    clearInterval(state.timer);
    state.isMeasuring = false;
    els.bMeasure.disabled = false; els.bMeasure.innerText = "自動測量";
    els.volt.disabled = false;
    state.stopPoints.push({ f: phys.f, v: phys.Vstop });
    drawStopChart();
  }

  // --- 繪圖 (金屬板裝置) ---
  const ctxChamber = els.cChamber.getContext('2d');
  const ctxCurr = els.cCurr.getContext('2d');
  const ctxStop = els.cStop.getContext('2d');

  function loop() {
    drawChamber();
    drawCurrentChart();
    requestAnimationFrame(loop);
  }

  function drawChamber() {
    const w = state.w, h = state.h;
    ctxChamber.clearRect(0, 0, w, h);

    // 金屬板位置參數
    const plateWidth = 14;
    const plateHeight = h * 0.5;
    const cathX = w * 0.25; // 左板 (陰極)
    const anoX = w * 0.75;  // 右板 (陽極)
    const plateY = (h - plateHeight) / 2;

    // 1. 繪製連接導線 (電路感)
    ctxChamber.beginPath();
    ctxChamber.strokeStyle = 'rgba(255,255,255,0.3)';
    ctxChamber.lineWidth = 2;
    // 左導線
    ctxChamber.moveTo(cathX, plateY + plateHeight/2);
    ctxChamber.lineTo(cathX - 40, plateY + plateHeight/2);
    ctxChamber.lineTo(cathX - 40, h + 10);
    // 右導線
    ctxChamber.moveTo(anoX + plateWidth, plateY + plateHeight/2);
    ctxChamber.lineTo(anoX + 40, plateY + plateHeight/2);
    ctxChamber.lineTo(anoX + 40, h + 10);
    ctxChamber.stroke();

    // 2. 繪製金屬板 (漸層質感)
    // 陰極 (Cathode)
    let gradC = ctxChamber.createLinearGradient(cathX, 0, cathX + plateWidth, 0);
    gradC.addColorStop(0, '#94a3b8'); gradC.addColorStop(0.5, '#e2e8f0'); gradC.addColorStop(1, '#64748b');
    ctxChamber.fillStyle = gradC;
    ctxChamber.fillRect(cathX, plateY, plateWidth, plateHeight);
    
    // 陽極 (Anode)
    let gradA = ctxChamber.createLinearGradient(anoX, 0, anoX + plateWidth, 0);
    gradA.addColorStop(0, '#64748b'); gradA.addColorStop(0.5, '#e2e8f0'); gradA.addColorStop(1, '#94a3b8');
    ctxChamber.fillStyle = gradA;
    ctxChamber.fillRect(anoX, plateY, plateWidth, plateHeight);

    // 3. 光子 (從外部飛向陰極內側)
    // 假設光源從左上方射入
    const sourceX = 20; 
    const sourceY = h * 0.45;
    
    if (phys.i > 0 && Math.random() < phys.i * 0.06) {
      state.photons.push({
        x: sourceX, y: sourceY, 
        tx: cathX + plateWidth, // 撞擊陰極右側面
        ty: plateY + Math.random() * plateHeight,
        p: 0,
        color: wavelengthToColor(phys.lambda)
      });
    }

    for (let i = state.photons.length - 1; i >= 0; i--) {
      let pt = state.photons[i];
      pt.p += 0.05;
      
      let cx = pt.x + (pt.tx - pt.x) * pt.p;
      let cy = pt.y + (pt.ty - pt.y) * pt.p;

      // 畫光束軌跡
      ctxChamber.beginPath();
      ctxChamber.strokeStyle = pt.color;
      ctxChamber.lineWidth = 1.5;
      // 拖尾效果
      ctxChamber.moveTo(pt.x + (pt.tx - pt.x) * Math.max(0, pt.p-0.15), 
                        pt.y + (pt.ty - pt.y) * Math.max(0, pt.p-0.15));
      ctxChamber.lineTo(cx, cy);
      ctxChamber.stroke();

      // 光子頭
      ctxChamber.fillStyle = '#fff';
      ctxChamber.beginPath(); ctxChamber.arc(cx, cy, 1.5, 0, Math.PI*2); ctxChamber.fill();

      if (pt.p >= 1) {
        spawnSparks(cx, cy, pt.color);
        if (phys.Kmax > 0 && Math.random() > 0.4) spawnElectron(cx, cy);
        state.photons.splice(i, 1);
      }
    }

    // 4. 電子 (從陰極飛向陽極)
    ctxChamber.fillStyle = '#60a5fa'; // Electron Blue
    ctxChamber.shadowBlur = 4; ctxChamber.shadowColor = '#3b82f6';
    for (let i = state.electrons.length - 1; i >= 0; i--) {
      let e = state.electrons[i];
      let speed = e.vx;

      // 阻擋電場效應
      if (!e.pass && e.x > cathX + plateWidth + (anoX - cathX - plateWidth) * 0.4) {
         speed = -1.5 - Math.random(); // 回頭
      }

      e.x += speed; e.y += e.vy; e.life++;

      ctxChamber.beginPath(); ctxChamber.arc(e.x, e.y, 3, 0, Math.PI*2); ctxChamber.fill();

      // 抵達陽極
      if (e.x >= anoX) {
        if (e.pass) spawnSparks(e.x, e.y, '#93c5fd');
        state.electrons.splice(i, 1);
        continue;
      }
      // 消失
      if (e.x < cathX || e.life > 300) {
        state.electrons.splice(i, 1);
      }
    }
    ctxChamber.shadowBlur = 0;
    drawSparks();
  }

  function spawnElectron(x, y) {
    const pass = Math.random() < phys.fraction;
    const baseSpeed = 1.5 + Math.sqrt(phys.Kmax) * 1.5; 
    state.electrons.push({
       x: x + 2, y: y, // 從板表面產生
       vx: baseSpeed * (0.8 + Math.random()*0.4), 
       vy: (Math.random()-0.5) * 2, 
       pass, life: 0 
    });
  }

  function spawnSparks(x, y, c) {
    for(let i=0; i<4; i++) state.sparks.push({x, y, vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3, life:1, c});
  }
  function drawSparks() {
    for(let i=state.sparks.length-1;i>=0;i--){
      let s = state.sparks[i]; s.x+=s.vx; s.y+=s.vy; s.life-=0.1;
      if(s.life<=0) { state.sparks.splice(i,1); continue; }
      ctxChamber.globalAlpha = s.life; ctxChamber.fillStyle = s.c; ctxChamber.fillRect(s.x, s.y, 2, 2);
    }
    ctxChamber.globalAlpha = 1;
  }

  function drawCurrentChart() {
    const w = state.w, h = els.cCurr.height;
    ctxCurr.clearRect(0, 0, w, h);
    ctxCurr.strokeStyle = 'rgba(255,255,255,0.1)';
    ctxCurr.beginPath(); ctxCurr.moveTo(0, h/2); ctxCurr.lineTo(w, h/2); ctxCurr.stroke();
    if(state.historyI.length < 2) return;
    ctxCurr.strokeStyle = '#4ade80'; ctxCurr.lineWidth = 2; ctxCurr.beginPath();
    const maxI = 50;
    state.historyI.forEach((val, i) => {
       const x = (i / 200) * w; const y = h - (val / maxI) * h;
       if(i===0) ctxCurr.moveTo(x, y); else ctxCurr.lineTo(x, y);
    });
    ctxCurr.stroke();
  }

  function drawStopChart() {
    const w = state.w, h = els.cStop.height;
    ctxStop.clearRect(0, 0, w, h);
    ctxStop.strokeStyle = '#94a3b8'; ctxStop.lineWidth = 1;
    ctxStop.beginPath();
    ctxStop.moveTo(30, h-20); ctxStop.lineTo(w, h-20);
    ctxStop.moveTo(30, h-20); ctxStop.lineTo(30, 0);
    ctxStop.stroke();
    ctxStop.fillStyle = '#94a3b8'; ctxStop.font = '10px Arial';
    ctxStop.fillText('f (x10¹⁴)', w-45, h-5); ctxStop.fillText('Vstop', 5, 10);

    const minF = 3, maxF = 15; const maxV = 8;
    const mapX = (f) => 30 + ((f - minF)/(maxF - minF)) * (w-30);
    const mapY = (v) => (h-20) - (v/maxV)*(h-20);

    const fStart = phys.phi / H_EV;
    if (fStart < maxF) {
      ctxStop.beginPath(); ctxStop.strokeStyle = 'rgba(56, 189, 248, 0.3)';
      ctxStop.setLineDash([4,4]);
      ctxStop.moveTo(mapX(fStart), mapY(0));
      ctxStop.lineTo(mapX(maxF), mapY(H_EV * maxF - phys.phi));
      ctxStop.stroke(); ctxStop.setLineDash([]);
    }
    ctxStop.fillStyle = '#f87171';
    state.stopPoints.forEach(p => {
      ctxStop.beginPath(); ctxStop.arc(mapX(p.f), mapY(p.v), 4, 0, Math.PI*2); ctxStop.fill();
    });
    if(phys.Kmax > 0) {
      ctxStop.fillStyle = '#facc15';
      ctxStop.beginPath(); ctxStop.arc(mapX(phys.f), mapY(phys.Kmax), 5, 0, Math.PI*2); ctxStop.fill();
    }
  }

  function wavelengthToColor(wl) {
    if (wl < 380) return '#e9d5ff'; // UV
    if (wl >= 380 && wl < 440) return '#8b5cf6';
    if (wl >= 440 && wl < 490) return '#3b82f6';
    if (wl >= 490 && wl < 510) return '#06b6d4';
    if (wl >= 510 && wl < 580) return '#22c55e';
    if (wl >= 580 && wl < 645) return '#eab308';
    if (wl >= 645 && wl < 780) return '#ef4444';
    return '#7f1d1d'; // IR
  }

  init();
});
</script>
</body>
</html>
